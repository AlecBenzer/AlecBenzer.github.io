<!doctype html>
<html>
  <head>
  <meta charset="utf-8" />
  
  <title>Salty now uses PBKDF2</title>
  
  <link href='http://fonts.googleapis.com/css?family=Crete+Round:400|Open+Sans:400,700|PT+Serif:400,700|Bubblegum+Sans' rel='stylesheet' type='text/css'>
  <link href="/css/reset.css" rel="stylesheet" media="screen" type="text/css" />
  <link href="/css/syntax.css" rel="stylesheet" media="screen" type="text/css" />
  <link href="/css/style.css" rel="stylesheet" media="screen" type="text/css" />
</head>

  <body>
    <div id="container">
      <div id="content">
        <h1>
          <a href="/blog/salty-now-uses-pbkdf">Salty now uses PBKDF2</a>
          <small class="date">16 Apr 2012</small>
        </h1>
        <p><a href='http://github.com/alecbenzer/salty'>Salty</a> now uses <a href='http://en.wikipedia.org/wiki/PBKDF2'>PBKDF2</a> via the <a href='https://rubygems.org/gems/pbkdf2'>pbkdf2 ruby gem</a>. Usage is still identical, but PBKDF2 should be a bit more secure than the iterated SHA512 that previous versions used.</p>

<p>There&#8217;s now just a single <code>salted_hash</code> function that looks like this:</p>
<div class='highlight'><pre><code class='ruby'><span class='k'>def</span> <span class='nc'>Salty</span><span class='o'>.</span><span class='nf'>salted_hash</span><span class='p'>(</span><span class='n'>str</span><span class='p'>,</span><span class='n'>salt</span><span class='p'>)</span>
  <span class='n'>pbkdf2</span> <span class='o'>=</span> <span class='no'>PBKDF2</span><span class='o'>.</span><span class='n'>new</span><span class='p'>(</span><span class='ss'>:password</span> <span class='o'>=&gt;</span> <span class='n'>str</span><span class='p'>,</span> <span class='ss'>:salt</span> <span class='o'>=&gt;</span> <span class='n'>salt</span><span class='p'>,</span> <span class='ss'>:iterations</span> <span class='o'>=&gt;</span> <span class='mi'>1000</span><span class='p'>)</span>
  <span class='n'>pbkdf2</span><span class='o'>.</span><span class='n'>hex_string</span>
<span class='k'>end</span>
</code></pre>
</div>
<p>as opposed to previously:</p>
<div class='highlight'><pre><code class='ruby'><span class='k'>def</span> <span class='nc'>Salty</span><span class='o'>.</span><span class='nf'>hash_fn</span><span class='p'>(</span><span class='n'>str</span><span class='p'>)</span>
  <span class='n'>sha512</span> <span class='o'>=</span> <span class='no'>Digest</span><span class='o'>::</span><span class='no'>SHA2</span><span class='o'>.</span><span class='n'>new</span><span class='p'>(</span><span class='mi'>512</span><span class='p'>)</span>
  <span class='n'>sha512</span><span class='o'>.</span><span class='n'>hexdigest</span><span class='p'>(</span><span class='n'>str</span><span class='p'>)</span>
<span class='k'>end</span>

<span class='k'>def</span> <span class='nc'>Salty</span><span class='o'>.</span><span class='nf'>salted_hash</span><span class='p'>(</span><span class='n'>str</span><span class='p'>,</span><span class='n'>salt</span><span class='p'>)</span>
  <span class='n'>res</span> <span class='o'>=</span> <span class='n'>str</span>
  <span class='mi'>100</span><span class='o'>.</span><span class='n'>times</span> <span class='k'>do</span>
    <span class='n'>res</span> <span class='o'>=</span> <span class='n'>hash_fn</span><span class='p'>(</span><span class='n'>res</span><span class='o'>+</span><span class='n'>salt</span><span class='p'>)</span>
  <span class='k'>end</span>
  <span class='n'>res</span>
<span class='k'>end</span>
</code></pre>
</div>
<p>Again, this is all just implementation-level stuff. You still just encrypt with <code>Salty.hash</code> and check with <code>Salty.check</code> (as described <a href='/blog/salty-hashing'>here</a>).</p>

<p>You&#8217;ll also notice the number of iterations has been raised from 100 to 1000. I might play around with varying the number of iterations based on the string length, if that does anything for security.</p>

<p>I might also add support for keeping track of what method was used to encrypt a particular string, as to maintain backwards compatibility with older versions, if the encryption method changes again. Right now you should <em>not</em> upgrade to 0.1 from 0.0.&#42;, or else you&#8217;ll be comparing PBKDF2 output to SHA512 output.</p>
        <a href="https://twitter.com/share" class="twitter-share-button" data-via="alecbenzer">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
<!-- Place this tag where you want the +1 button to render -->
<g:plusone size="medium"></g:plusone>

<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
   var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
   po.src = 'https://apis.google.com/js/plusone.js';
   var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
   })();
 </script>
 <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'alecbenzer';
    var disqus_developer = 1;

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

      <div id="footer">
  <p id="name"><a href="/">Alec Benzer</a></p>
  <p>Follow <a href="http://twitter.com/alecbenzer">@alecbenzer</a> on twitter.</p>
</div>

      <div id="back_to_index"><a href="/blog">&larr; home</a></div>
    </div>
  </body>
</html>
