<!doctype html>
<html>
  <head>
  <meta charset="utf-8" />
  
  <title>Spell checking with tries in C++: Part 1</title>
  
  <link href='http://fonts.googleapis.com/css?family=Crete+Round:400|Open+Sans:400,700|PT+Serif:400,700|Bubblegum+Sans' rel='stylesheet' type='text/css'>
  <link href="/css/reset.css" rel="stylesheet" media="screen" type="text/css" />
  <link href="/css/syntax.css" rel="stylesheet" media="screen" type="text/css" />
  <link href="/css/style.css" rel="stylesheet" media="screen" type="text/css" />
</head>

  <body>
    <div id="container">
      <div id="content">
        <h1>
          <a href="/blog/spell-checking-part-1">Spell checking with tries in C++: Part 1</a>
          <small class="date">26 Apr 2012</small>
        </h1>
        <p><a href='http://en.wikipedia.org/wiki/Trie'>Tries</a> are a really cool data structure used for storing strings (and potentially other things) efficiently and compactly. They can have speed and space advantages over trees for and hash tables when used as associative arrays, but the linked nature of tries lets you do other cool things with them. As an example, let&#8217;s write a spell-checker in C++.</p>

<p>A trie (<i>technically</i> pronounced &#8220;tree&#8221;, but commonly &#8220;try&#8221;) is basically just a special kind tree. Generally speaking, each node in the trie can have any number of children, but for our purposes, we&#8217;ll say that each node has 26 slots for children, one for each letter of the alphabet.</p>

<p>Each node in the trie represents some string. Starting from the root of the tree, any path to any other node will go over edges labeled by letters of the alphabet. The sequence of letters you pass through to get to the node in question tell you what string is associated with that node. For example, starting from the root, if you take a &#8216;c&#8217; edge, then an &#8216;a&#8217; edge, and then a &#8216;t&#8217; edge, the node you end up at represents the string &#8220;cat&#8221;.</p>

<p>Each node also has a <code>final</code> property, intended to indicate whether we want to actually count that word as part of the trie. For example, in the &#8220;cat&#8221; trie above, &#8220;c&#8221; and &#8220;ca&#8221; are also strings stored by the trie. If we want to make it so that only &#8220;cat&#8221; (and not &#8220;ca&#8221; or &#8220;c&#8221;) should be considered part of our trie, we&#8217;ll set the &#8220;cat&#8221; node be final, and set the &#8220;c&#8221; and &#8220;ca&#8221; nodes to not final.</p>

<p>From this description, searching for a string in a trie is easy. If we have a particular string, all we need to do is follow the edges in the trie that correspond to the letters of the string. If we end up at a final node, the string is stored by the trie. If the node we get to is not final, or if we hit a null node along the way, then the string isn&#8217;t stored by the trie.</p>

<h2 id='coding_the_trie'>Coding the trie</h2>

<p>So fire up your text editor and get coding. The first thing we&#8217;ll need is a <code>Node</code> class (which will end up being embedded in the <code>trie</code> class). The skeleton for the <code>Node</code> class looks like this:</p>
<div class='highlight'><pre><code class='cpp'><span class='k'>struct</span> <span class='n'>Node</span>
<span class='p'>{</span>
  <span class='n'>Node</span><span class='o'>*</span> <span class='n'>children</span><span class='p'>[</span><span class='mi'>26</span><span class='p'>];</span>
  <span class='kt'>bool</span> <span class='n'>final</span><span class='p'>;</span>
<span class='p'>};</span>
</code></pre>
</div>
<p>Simple enough. We have our 26 children and our final property. Now we just initialize stuff with a constructor:</p>
<div class='highlight'><pre><code class='cpp'><span class='n'>Node</span><span class='p'>()</span> <span class='o'>:</span> <span class='n'>final</span><span class='p'>(</span><span class='kc'>false</span><span class='p'>)</span>
<span class='p'>{</span>
  <span class='k'>for</span><span class='p'>(</span><span class='kt'>int</span> <span class='n'>i</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span><span class='n'>i</span> <span class='o'>&lt;</span> <span class='mi'>26</span><span class='p'>;</span><span class='o'>++</span><span class='n'>i</span><span class='p'>)</span>
    <span class='n'>children</span><span class='p'>[</span><span class='n'>i</span><span class='p'>]</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span> <span class='c1'>//ie, NULL</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>We also need a destructor for memory cleanup (technically we&#8217;d also want a copy constructor, but we&#8217;ll be careful about not passing tries by value)</p>
<div class='highlight'><pre><code class='cpp'><span class='o'>~</span><span class='n'>Node</span><span class='p'>()</span>
<span class='p'>{</span>
  <span class='k'>for</span><span class='p'>(</span><span class='kt'>int</span> <span class='n'>i</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span><span class='n'>i</span> <span class='o'>&lt;</span> <span class='mi'>26</span><span class='p'>;</span><span class='o'>++</span><span class='n'>i</span><span class='p'>)</span>
    <span class='k'>if</span><span class='p'>(</span><span class='n'>children</span><span class='p'>[</span><span class='n'>i</span><span class='p'>])</span> <span class='k'>delete</span> <span class='n'>children</span><span class='p'>[</span><span class='n'>i</span><span class='p'>];</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>We&#8217;ll also make a method that makes accessing the <code>children</code> array easier:</p>
<div class='highlight'><pre><code class='cpp'><span class='n'>Node</span><span class='o'>*&amp;</span> <span class='n'>child</span><span class='p'>(</span><span class='kt'>char</span> <span class='n'>c</span><span class='p'>)</span>
<span class='p'>{</span>
  <span class='k'>return</span> <span class='n'>children</span><span class='p'>[</span><span class='n'>tolower</span><span class='p'>(</span><span class='n'>c</span><span class='p'>)</span><span class='o'>-</span><span class='sc'>&#39;a&#39;</span><span class='p'>];</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>This method converts all characters to lowercase (using the <code>tolower</code> function found in <code>cctype</code>) so we don&#8217;t need to worry about the case of the strings we index/search. Note that it also returns a reference, so we can modify the contents of <code>children</code> via this method (which is what we want, <code>child</code> is just a convenience access method).</p>

<p>Now, onto the class for the trie itself:</p>
<div class='highlight'><pre><code class='cpp'><span class='k'>class</span> <span class='nc'>Trie</span>
<span class='p'>{</span>
  <span class='k'>public</span><span class='o'>:</span>
    <span class='k'>struct</span> <span class='n'>Node</span>
    <span class='p'>{</span>
      <span class='c1'>//...</span>
    <span class='p'>};</span>

    <span class='n'>Trie</span><span class='p'>()</span>
    <span class='p'>{</span>
      <span class='n'>root</span> <span class='o'>=</span> <span class='k'>new</span> <span class='n'>Node</span><span class='p'>;</span>
    <span class='p'>}</span>

    <span class='o'>~</span><span class='n'>Trie</span><span class='p'>()</span>
    <span class='p'>{</span>
      <span class='k'>delete</span> <span class='n'>root</span><span class='p'>;</span>
    <span class='p'>}</span>

    <span class='kt'>void</span> <span class='n'>add</span><span class='p'>(</span><span class='n'>string</span> <span class='n'>word</span><span class='p'>)</span>
    <span class='p'>{</span>
      <span class='c1'>//...</span>
    <span class='p'>}</span>

    <span class='kt'>void</span> <span class='n'>search</span><span class='p'>(</span><span class='n'>string</span> <span class='n'>word</span><span class='p'>)</span>
    <span class='p'>{</span>
      <span class='c1'>//...</span>
    <span class='p'>}</span>

  <span class='k'>private</span><span class='o'>:</span>
    <span class='n'>Node</span><span class='o'>*</span> <span class='n'>root</span><span class='p'>;</span>
<span class='p'>};</span>
</code></pre>
</div>
<p>We have just one instance variable: a pointer to the root node of the trie. The constructor allocates memory for the root and the destructor deals with clearing it. The interesting stuff is in <code>add</code> and <code>search</code>.</p>

<p><code>add</code> takes a string and iterates over its characters, adding new nodes along the way if it needs to, and setting the node it ends up at to final.</p>
<div class='highlight'><pre><code class='cpp'><span class='kt'>void</span> <span class='n'>add</span><span class='p'>(</span><span class='n'>string</span> <span class='n'>word</span><span class='p'>)</span>
<span class='p'>{</span>
  <span class='n'>Node</span><span class='o'>*</span> <span class='n'>curr</span> <span class='o'>=</span> <span class='n'>root</span><span class='p'>;</span>
  <span class='k'>for</span><span class='p'>(</span><span class='kt'>int</span> <span class='n'>i</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span><span class='n'>i</span> <span class='o'>&lt;</span> <span class='n'>word</span><span class='p'>.</span><span class='n'>length</span><span class='p'>();</span><span class='o'>++</span><span class='n'>i</span><span class='p'>)</span>
  <span class='p'>{</span>
    <span class='kt'>char</span><span class='o'>&amp;</span> <span class='n'>c</span> <span class='o'>=</span> <span class='n'>word</span><span class='p'>[</span><span class='n'>i</span><span class='p'>];</span>
    <span class='k'>if</span><span class='p'>(</span><span class='o'>!</span><span class='n'>isalpha</span><span class='p'>(</span><span class='n'>c</span><span class='p'>))</span> <span class='k'>continue</span><span class='p'>;</span>
    <span class='k'>if</span><span class='p'>(</span><span class='o'>!</span><span class='n'>curr</span><span class='o'>-&gt;</span><span class='n'>child</span><span class='p'>(</span><span class='n'>c</span><span class='p'>))</span>
      <span class='n'>curr</span><span class='o'>-&gt;</span><span class='n'>child</span><span class='p'>(</span><span class='n'>c</span><span class='p'>)</span> <span class='o'>=</span> <span class='k'>new</span> <span class='n'>Node</span><span class='p'>;</span>
    <span class='n'>curr</span> <span class='o'>=</span> <span class='n'>curr</span><span class='o'>-&gt;</span><span class='n'>child</span><span class='p'>(</span><span class='n'>c</span><span class='p'>);</span>
  <span class='p'>}</span>
  <span class='n'>curr</span><span class='o'>-&gt;</span><span class='n'>final</span> <span class='o'>=</span> <span class='kc'>true</span><span class='p'>;</span>
<span class='p'>}</span>
</code></pre>
</div>
<p><code>search</code> looks almost identical. We still iterate over the string, except now we just fail if we see a missing node, and, if that never happens, we check to see if the node we end up at is final.</p>
<div class='highlight'><pre><code class='cpp'><span class='kt'>bool</span> <span class='n'>search</span><span class='p'>(</span><span class='n'>string</span> <span class='n'>word</span><span class='p'>)</span>
<span class='p'>{</span>
  <span class='n'>Node</span><span class='o'>*</span> <span class='n'>curr</span> <span class='o'>=</span> <span class='n'>root</span><span class='p'>;</span>
  <span class='k'>for</span><span class='p'>(</span><span class='kt'>int</span> <span class='n'>i</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span><span class='n'>i</span> <span class='o'>&lt;</span> <span class='n'>word</span><span class='p'>.</span><span class='n'>size</span><span class='p'>();</span><span class='o'>++</span><span class='n'>i</span><span class='p'>)</span>
  <span class='p'>{</span>
    <span class='kt'>char</span><span class='o'>&amp;</span> <span class='n'>c</span> <span class='o'>=</span> <span class='n'>word</span><span class='p'>[</span><span class='n'>i</span><span class='p'>];</span>
    <span class='k'>if</span><span class='p'>(</span><span class='o'>!</span><span class='n'>isalpha</span><span class='p'>(</span><span class='n'>c</span><span class='p'>))</span> <span class='k'>continue</span><span class='p'>;</span>
    <span class='k'>if</span><span class='p'>(</span><span class='o'>!</span><span class='n'>curr</span><span class='o'>-&gt;</span><span class='n'>child</span><span class='p'>(</span><span class='n'>c</span><span class='p'>))</span> <span class='k'>return</span> <span class='kc'>false</span><span class='p'>;</span>
    <span class='n'>curr</span> <span class='o'>=</span> <span class='n'>curr</span><span class='o'>-&gt;</span><span class='n'>child</span><span class='p'>(</span><span class='n'>c</span><span class='p'>);</span>
  <span class='p'>}</span>
  <span class='k'>return</span> <span class='n'>curr</span><span class='o'>-&gt;</span><span class='n'>final</span><span class='p'>;</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>And that&#8217;s it. Here&#8217;s the whole <code>Trie</code> class:</p>
<div class='highlight'><pre><code class='cpp'><span class='k'>class</span> <span class='nc'>Trie</span>
<span class='p'>{</span>
  <span class='k'>public</span><span class='o'>:</span>
    <span class='k'>struct</span> <span class='n'>Node</span>
    <span class='p'>{</span>
      <span class='n'>Node</span><span class='p'>()</span> <span class='o'>:</span> <span class='n'>final</span><span class='p'>(</span><span class='kc'>false</span><span class='p'>)</span>
      <span class='p'>{</span>
        <span class='k'>for</span><span class='p'>(</span><span class='kt'>int</span> <span class='n'>i</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span><span class='n'>i</span> <span class='o'>&lt;</span> <span class='mi'>26</span><span class='p'>;</span><span class='o'>++</span><span class='n'>i</span><span class='p'>)</span>
          <span class='n'>children</span><span class='p'>[</span><span class='n'>i</span><span class='p'>]</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span>
      <span class='p'>}</span>

      <span class='o'>~</span><span class='n'>Node</span><span class='p'>()</span>
      <span class='p'>{</span>
        <span class='k'>for</span><span class='p'>(</span><span class='kt'>int</span> <span class='n'>i</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span><span class='n'>i</span> <span class='o'>&lt;</span> <span class='mi'>26</span><span class='p'>;</span><span class='o'>++</span><span class='n'>i</span><span class='p'>)</span>
          <span class='k'>if</span><span class='p'>(</span><span class='n'>children</span><span class='p'>[</span><span class='n'>i</span><span class='p'>])</span> <span class='k'>delete</span> <span class='n'>children</span><span class='p'>[</span><span class='n'>i</span><span class='p'>];</span>
      <span class='p'>}</span>

      <span class='n'>Node</span><span class='o'>*&amp;</span> <span class='n'>child</span><span class='p'>(</span><span class='kt'>char</span> <span class='n'>c</span><span class='p'>)</span>
      <span class='p'>{</span>
        <span class='k'>return</span> <span class='n'>children</span><span class='p'>[</span><span class='n'>tolower</span><span class='p'>(</span><span class='n'>c</span><span class='p'>)</span><span class='o'>-</span><span class='sc'>&#39;a&#39;</span><span class='p'>];</span>
      <span class='p'>}</span>

      <span class='n'>Node</span><span class='o'>*</span> <span class='n'>children</span><span class='p'>[</span><span class='mi'>26</span><span class='p'>];</span>
      <span class='kt'>bool</span> <span class='n'>final</span><span class='p'>;</span>
    <span class='p'>};</span>

    <span class='n'>Trie</span><span class='p'>()</span>
    <span class='p'>{</span>
      <span class='n'>root</span> <span class='o'>=</span> <span class='k'>new</span> <span class='n'>Node</span><span class='p'>;</span>
    <span class='p'>}</span>

    <span class='o'>~</span><span class='n'>Trie</span><span class='p'>()</span>
    <span class='p'>{</span>
      <span class='k'>delete</span> <span class='n'>root</span><span class='p'>;</span>
    <span class='p'>}</span>

    <span class='kt'>void</span> <span class='n'>add</span><span class='p'>(</span><span class='n'>string</span> <span class='n'>word</span><span class='p'>)</span>
    <span class='p'>{</span>
      <span class='n'>Node</span><span class='o'>*</span> <span class='n'>curr</span> <span class='o'>=</span> <span class='n'>root</span><span class='p'>;</span>
      <span class='k'>for</span><span class='p'>(</span><span class='kt'>int</span> <span class='n'>i</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span><span class='n'>i</span> <span class='o'>&lt;</span> <span class='n'>word</span><span class='p'>.</span><span class='n'>length</span><span class='p'>();</span><span class='o'>++</span><span class='n'>i</span><span class='p'>)</span>
      <span class='p'>{</span>
        <span class='kt'>char</span><span class='o'>&amp;</span> <span class='n'>c</span> <span class='o'>=</span> <span class='n'>word</span><span class='p'>[</span><span class='n'>i</span><span class='p'>];</span>
        <span class='k'>if</span><span class='p'>(</span><span class='o'>!</span><span class='n'>isalpha</span><span class='p'>(</span><span class='n'>c</span><span class='p'>))</span> <span class='k'>continue</span><span class='p'>;</span>
        <span class='k'>if</span><span class='p'>(</span><span class='o'>!</span><span class='n'>curr</span><span class='o'>-&gt;</span><span class='n'>child</span><span class='p'>(</span><span class='n'>c</span><span class='p'>))</span>
          <span class='n'>curr</span><span class='o'>-&gt;</span><span class='n'>child</span><span class='p'>(</span><span class='n'>c</span><span class='p'>)</span> <span class='o'>=</span> <span class='k'>new</span> <span class='n'>Node</span><span class='p'>;</span>
        <span class='n'>curr</span> <span class='o'>=</span> <span class='n'>curr</span><span class='o'>-&gt;</span><span class='n'>child</span><span class='p'>(</span><span class='n'>c</span><span class='p'>);</span>
      <span class='p'>}</span>
      <span class='n'>curr</span><span class='o'>-&gt;</span><span class='n'>final</span> <span class='o'>=</span> <span class='kc'>true</span><span class='p'>;</span>
    <span class='p'>}</span>

    <span class='kt'>bool</span> <span class='n'>search</span><span class='p'>(</span><span class='n'>string</span> <span class='n'>word</span><span class='p'>)</span>
    <span class='p'>{</span>
      <span class='n'>Node</span><span class='o'>*</span> <span class='n'>curr</span> <span class='o'>=</span> <span class='n'>root</span><span class='p'>;</span>
      <span class='k'>for</span><span class='p'>(</span><span class='kt'>int</span> <span class='n'>i</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span><span class='n'>i</span> <span class='o'>&lt;</span> <span class='n'>word</span><span class='p'>.</span><span class='n'>size</span><span class='p'>();</span><span class='o'>++</span><span class='n'>i</span><span class='p'>)</span>
      <span class='p'>{</span>
        <span class='kt'>char</span><span class='o'>&amp;</span> <span class='n'>c</span> <span class='o'>=</span> <span class='n'>word</span><span class='p'>[</span><span class='n'>i</span><span class='p'>];</span>
        <span class='k'>if</span><span class='p'>(</span><span class='o'>!</span><span class='n'>isalpha</span><span class='p'>(</span><span class='n'>c</span><span class='p'>))</span> <span class='k'>continue</span><span class='p'>;</span>
        <span class='k'>if</span><span class='p'>(</span><span class='o'>!</span><span class='n'>curr</span><span class='o'>-&gt;</span><span class='n'>child</span><span class='p'>(</span><span class='n'>c</span><span class='p'>))</span> <span class='k'>return</span> <span class='kc'>false</span><span class='p'>;</span>
        <span class='n'>curr</span> <span class='o'>=</span> <span class='n'>curr</span><span class='o'>-&gt;</span><span class='n'>child</span><span class='p'>(</span><span class='n'>c</span><span class='p'>);</span>
      <span class='p'>}</span>
      <span class='k'>return</span> <span class='n'>curr</span><span class='o'>-&gt;</span><span class='n'>final</span><span class='p'>;</span>
    <span class='p'>}</span>
  <span class='k'>private</span><span class='o'>:</span>
    <span class='n'>Node</span><span class='o'>*</span> <span class='n'>root</span><span class='p'>;</span>
<span class='p'>};</span>
</code></pre>
</div>
<h2 id='a_little_command_line_interface'>A little command line interface</h2>

<p>Now all that&#8217;s left to do is throw up a simple little interface to our program. We&#8217;ll have a simple command line interface with two commands: <code>add &lt;word&gt;</code>, and <code>search &lt;word&gt;</code>.</p>
<div class='highlight'><pre><code class='cpp'><span class='kt'>int</span> <span class='n'>main</span><span class='p'>()</span>
<span class='p'>{</span>
  <span class='n'>Trie</span> <span class='n'>trie</span><span class='p'>;</span>
  <span class='n'>string</span> <span class='n'>tmp</span><span class='p'>;</span>

  <span class='k'>for</span><span class='p'>(;;)</span> <span class='c1'>//loop fo-evah (or until Ctrl+C)</span>
  <span class='p'>{</span>
    <span class='n'>cout</span> <span class='o'>&lt;&lt;</span> <span class='s'>&quot;&gt; &quot;</span><span class='p'>;</span>
    <span class='n'>cin</span> <span class='o'>&gt;&gt;</span> <span class='n'>tmp</span><span class='p'>;</span>
    <span class='k'>if</span><span class='p'>(</span><span class='n'>tmp</span> <span class='o'>==</span> <span class='s'>&quot;add&quot;</span><span class='p'>)</span>
    <span class='p'>{</span>
      <span class='n'>cin</span> <span class='o'>&gt;&gt;</span> <span class='n'>tmp</span><span class='p'>;</span>
      <span class='n'>trie</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='n'>tmp</span><span class='p'>);</span>
      <span class='n'>cout</span> <span class='o'>&lt;&lt;</span> <span class='s'>&quot;added </span><span class='se'>\&quot;</span><span class='s'>&quot;</span> <span class='o'>&lt;&lt;</span> <span class='n'>tmp</span> <span class='o'>&lt;&lt;</span> <span class='s'>&quot;</span><span class='se'>\&quot;</span><span class='s'>&quot;</span><span class='p'>;</span>
    <span class='p'>}</span>
    <span class='k'>else</span> <span class='k'>if</span><span class='p'>(</span><span class='n'>tmp</span> <span class='o'>==</span> <span class='s'>&quot;search&quot;</span><span class='p'>)</span>
    <span class='p'>{</span>
      <span class='n'>cin</span> <span class='o'>&gt;&gt;</span> <span class='n'>tmp</span><span class='p'>;</span>
      <span class='n'>cout</span> <span class='o'>&lt;&lt;</span> <span class='n'>trie</span><span class='p'>.</span><span class='n'>search</span><span class='p'>(</span><span class='n'>tmp</span><span class='p'>);</span>
    <span class='p'>}</span>
    <span class='k'>else</span>
      <span class='n'>cerr</span> <span class='o'>&lt;&lt;</span> <span class='s'>&quot;unrecognized command&quot;</span><span class='p'>;</span>
    <span class='n'>cout</span> <span class='o'>&lt;&lt;</span> <span class='n'>endl</span><span class='p'>;</span>
  <span class='p'>}</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>And that&#8217;s that. Compile your code (<code>g++ -o spell-check main.cpp</code> should work on UNIX) and fire her up.</p>
<div class='highlight'><pre><code class='text'>$ ./spell-check 
&gt; search bob
0
&gt; add bob
added &quot;bob&quot;
&gt; search bob
1
&gt; add jacob
added &quot;jacob&quot;
&gt; search jacob
1
&gt; search jaco
0
&gt; search jacobb
0
</code></pre>
</div>
<h2 id='prefilling_the_trie_with_a_dictionary'>Pre-filling the trie with a dictionary</h2>

<p>Being able to index our own words is pretty cool, but really, we&#8217;d like to have our trie pre-packaged with words from a dictionary. Luckily, most UNIX systems have a dictionary file available that makes this really easy. For me, the file is <code>/usr/share/dict/words</code>. All you have to do is open that file with an <code>ifstream</code> and add all the words in it to our trie before we enter the command-line loop.</p>
<div class='highlight'><pre><code class='cpp'><span class='n'>cout</span> <span class='o'>&lt;&lt;</span> <span class='s'>&quot;indexing dictionary...&quot;</span><span class='p'>;</span>
<span class='n'>ifstream</span> <span class='n'>dict</span><span class='p'>(</span><span class='s'>&quot;/usr/share/dict/words&quot;</span><span class='p'>);</span>
<span class='k'>while</span><span class='p'>(</span><span class='o'>!</span><span class='n'>dict</span><span class='p'>.</span><span class='n'>eof</span><span class='p'>())</span>
<span class='p'>{</span>
  <span class='n'>dict</span> <span class='o'>&gt;&gt;</span> <span class='n'>tmp</span><span class='p'>;</span>
  <span class='n'>trie</span><span class='p'>.</span><span class='n'>add</span><span class='p'>(</span><span class='n'>tmp</span><span class='p'>);</span>
<span class='p'>}</span>
<span class='n'>cout</span> <span class='o'>&lt;&lt;</span> <span class='s'>&quot; done&quot;</span> <span class='o'>&lt;&lt;</span> <span class='n'>endl</span><span class='p'>;</span>
</code></pre>
</div>
<p>And now just re-compile and run:</p>
<div class='highlight'><pre><code class='text'>$ ./spell-check 
indexing dictionary... done
&gt; search apple
1
&gt; search hello
1
&gt; search helo
0
&gt; search helloo
0
</code></pre>
</div>
<p>Of course, we can still index our own words if we want:</p>
<div class='highlight'><pre><code class='text'>search helloo
0
&gt; add helloo
added &quot;helloo&quot;
&gt; search helloo
1
</code></pre>
</div>
<p>Now we have our little spell-checker. Well, sort of. <em>Technically</em> what we&#8217;ve made is a spell-checker: it checks to see if you&#8217;ve spelled things right. What we really want though, is something that can recognize when we&#8217;ve spelled something wrong and also give us suggested corrections. This is when our trie will start becoming useful (after all, we could have done all this with a hash-table or other associative array as well, although our trie is most likely slightly more efficient).</p>

<p>I&#8217;ll put out a part 2 soon, where I&#8217;ll cover actually generating the suggestions. For your reference, here&#8217;s <a href='https://gist.github.com/2504661'>the code so far, in its entirety</a>.</p>
        <a href="https://twitter.com/share" class="twitter-share-button" data-via="alecbenzer">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
<!-- Place this tag where you want the +1 button to render -->
<g:plusone size="medium"></g:plusone>

<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
   var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
   po.src = 'https://apis.google.com/js/plusone.js';
   var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
   })();
 </script>
 <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'alecbenzer';
    var disqus_developer = 1;

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

      <div id="footer">
  <p id="name"><a href="/">Alec Benzer</a></p>
  <p>Follow <a href="http://twitter.com/alecbenzer">@alecbenzer</a> on twitter.</p>
</div>

      <div id="back_to_index"><a href="/blog">&larr; home</a></div>
    </div>
  </body>
</html>
