<!doctype html>
<html>
  <head>
  <meta charset="utf-8" />
  
  <title>RSA Encryption</title>
  
  <link href='http://fonts.googleapis.com/css?family=Crete+Round:400|Open+Sans:400,700|PT+Serif:400,700|Bubblegum+Sans' rel='stylesheet' type='text/css'>
  <link href="/css/reset.css" rel="stylesheet" media="screen" type="text/css" />
  <link href="/css/syntax.css" rel="stylesheet" media="screen" type="text/css" />
  <link href="/css/style.css" rel="stylesheet" media="screen" type="text/css" />
</head>

  <body>
    <div id="container">
      <div id="content">
        <h1>
          <a href="/blog/rsa">RSA Encryption</a>
          <small class="date">21 Dec 2010</small>
        </h1>
        <p>So I recently became interested in how RSA encryption works after my dad asked me a question about it I couldn&#8217;t answer. My attempt to explain what I now know:</p>

<p>So, some general stuff about RSA. Let&#8217;s say Bill wants to send a secret message to John. Bill asks John to generate a pair of RSA keys, a private key and a public key. John then sends the public key to Bill and keeps the private key on his own computer. Bill uses the public key to encrypt the secret message, and then sends it along to Bill. Once Bill gets the message, he can use the private key that he kept to decrypt it and read John&#8217;s message. Now, let&#8217;s say Tom has been watching the information that Bill and John transmit to each other. Like most encryptions, if Tom got a hold of the encrypted version of the message, he wouldn&#8217;t be able to read it (at least in any reasonable amount of time). But, remember that John had also sent the public key to Bill. What if Tom had both the public key, which John used to encrypt the message, and the encrypted message itself. What&#8217;s really cool about RSA is that even with both of those, Tom still wouldn&#8217;t be able to read the message. This, however, leads to something that&#8217;s initially somewhat counter-intuitive. John takes his message, encrypts it with the public key, but John himself cannot decrypt the message he just encrypted. Of course, John probably still has a copy of the original message, but if it somehow was deleted, he would have no way of recovering it from the encrypted message (again, in a reasonable amount of time), even though he was the one who encrypted it.</p>

<p>Now, onto the semantics of how RSA actually works. From now on, assume that John&#8217;s original message was some number, <code>M</code> (if it wasn&#8217;t, John and Bill would need some agreed-upon way of converting the message into a number and back). John encrypts the message by taking <code>M</code> and raising it to the power of some number which we&#8217;ll call <code>e</code>, and then taking the modulus of that with some number <code>n</code>. Ie, <code>C = M ^ e mod n</code>. <code>a mod b</code> just means the remainder after <code>a</code> is divided by <code>b</code> (It&#8217;s like in middle school where you&#8217;d solve long division problems with remainders at the end. Ie, <code>19 / 7</code> is <code>2R5</code>, which means that <code>19 mod 7 = 5</code>). Now we have some encrypted message <code>C</code>. We&#8217;d like to be able to decrypt it. To do so, we need to know some other exponent, d, so that when we raise <code>C</code> to the <code>dth</code> power, and then mod it by <code>n</code> again, we&#8217;ll get our original message <code>M</code> back. Or, to put it another way, we need to find a <code>d</code> such that <code>(M ^ e) ^ d mod n = M</code>, or just <code>M ^ (e * d) mod n = M</code>. How do we do this? Well, it involves some kind of complicated math, but, for now, it can suffice to say that in order to find out what this <code>d</code> is, we need to compute what&#8217;s called the totient of <code>n</code>. The totient of <code>n</code> is just the amount of numbers less than or equal to <code>n</code> that are coprime to it. Ie, the amount of numbers less than or equal to <code>n</code> that share no factors (other than <code>1</code>) with <code>n</code>. So, we can compute the totient, and then use that to find a <code>d</code> exponent that matches our <code>e</code> exponent.</p>

<p>But this hasn&#8217;t really solved much. If, given <code>e</code> and <code>n</code>, we can compute what the totient of <code>n</code> is, then so can someone else who gets their hands on the public key (which is basically just <code>e</code> and <code>n</code>). A possible solution would be to make <code>n</code> so big that it would take far too much time to compute the totient. Well, we could do that, but then we would have just as much difficulty computing the totient to generate the keys. The algorithm needs some kind of edge over people who have the public key, a way that it can compute the totient of <code>n</code> efficiently and others cannot. Well, instead of just picking some big number for <code>n</code>, we could pick a big prime number for <code>n</code>. We know that the totient of a prime number is just one less than itself (because if a number is prime, it has absolutely no factors, so it can&#8217;t share any factors with numbers less than it, but we don&#8217;t count the number <code>1</code>), so we can use this fact to quickly “compute” the totient. This is a minor improvement, but not really, because all that someone needs to do is determine that the the number <code>n</code> is prime, and then they can crack the encryption. Now, finding out if a very big number is prime can&#8217;t be done too efficiently, but it only needs to be done once, and then people might say “aha, they&#8217;re just always using prime numbers for <code>n</code>.” And then everyone would know that the totient of <code>n</code> is always <code>n-1</code>. This is also doesn&#8217;t work if your algorithm is ever made public. So this edge still isn&#8217;t good enough.</p>

<p>So, what if, instead of using a prime number for <code>n</code>, we use the product of two primes numbers <code>p</code> and <code>q</code>. The totient of <code>p * q</code> is just <code>p * q - p - q + 1 = (p-1)(q-1)</code>. (If a prime number has no numbers less than it that is is coprime with, then the product of two primes is almost the same, except that it is coprime with <code>p</code>, <code>2p</code>, <code>3p</code>, <code>4p</code>, &#8230; ,<code>(q-1)p</code>, <code>qp</code>, and with <code>q</code>, <code>2q</code>, <code>3q</code>, &#8230; , <code>(p-1)q</code>, <code>pq</code>. So there are <code>q + p</code> numbers that it is coprime with, but one of them is the same, so this leaves us with the totient being <code>p * q - (p + q - 1) = p * q - p - q + 1 = (p-1)(q-1)</code>). Using this fact, the key generation program can generate two primes <code>p</code> and <code>q</code>, set <code>n = p * q</code>, and then easily compute the totient as <code>(p-1)(q-1)</code>. The two prime numbers are then thrown away for good. Now, if someone wanted to crack the encryption, they would have to find out which two prime numbers <code>p</code> and <code>q</code> were originally multiplied to get <code>n</code>. For big enough values for <code>n</code>, this can&#8217;t be done in a reasonable amount of time (even though the key generation program can compute it almost instantly, as it knows what <code>p</code> and <code>q</code> are). And there, our encryption is safe. Even if someone gets their hands on the public key, they still woudn&#8217;t be able to crack the encrypted message.</p>
        <a href="https://twitter.com/share" class="twitter-share-button" data-via="alecbenzer">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
<!-- Place this tag where you want the +1 button to render -->
<g:plusone size="medium"></g:plusone>

<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
   var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
   po.src = 'https://apis.google.com/js/plusone.js';
   var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
   })();
 </script>
 <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'alecbenzer';
    var disqus_developer = 1;

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

      <div id="footer">
  <p id="name"><a href="/">Alec Benzer</a></p>
  <p>Follow <a href="http://twitter.com/alecbenzer">@alecbenzer</a> on twitter.</p>
</div>

      <div id="back_to_index"><a href="/blog">&larr; home</a></div>
    </div>
  </body>
</html>
