---
title: software is human
layout: post
listed: false
...

A lot of people think software development is very precise and and machine like, because computers are precise and machine-like. I guess I shouldn't say that software development _isn't_ precise, it is precise. But it's also very very human in a way.

I like to compare source code to blueprints (which I think is maybe a cliched analogy at this point but...). Software is really a blueprint. And a blueprint, is very precise, yes, but a blueprint is in many ways a thing for humans. Humans are the primary creators and consumers of blueprints. A human creates a blueprint and then a series of other people read the blueprint to create whatever the it's trying to describe. 

Source code is a precise description not of a building or structure but of an algorithm or a procedure (sometimes very complicated, non-linear procedures); it's very carefully describing a bunch of stuff to do in some kind of order. 

Software development is creating those blueprints for those procedures. And the blueprints don't need to be executed by people in the same way that regular blueprints do -- the computer is the one that goes and does the things that the the blueprint describes as opposed to a traditional blueprint where humans go and implement what it describes. But humans still write the blueprints, and humans  also read by humans not to implement it directly but to understand what it's describing.

The point here is just that software development is actually very human thing. And you know, well, of course there are precise things about it. 

This the parts of it that I think we have you know as a society and as a you know, as an industry what's the parts of developing software, you know efficiently and effectively and safely but parts of it that we have the most trouble with is not you know, it's not the precise things it's not like floating point math isn't good enough and that's why we can't build good software it's not like, you know compilers aren't fast enough well. 

I mean that sometimes compilers are in fast enough but the but those kinds of issues are. I think the real the real costly problems in software, they're real causing problems are are the soft things they're the things like figuring out the best ways to. You know, sort of organize our you know blueprints so that we can work with them easily that's what's that's what that's really hard and and it's hard in large part because it's not a precise problem it's hard because it's a problem that involves. 

Hold on a second, let me just make sure I've been recording. Cool what happened? 

Yeah, so it's a it's a problem that involves. 

Understanding how humans think understanding how humans process complexity and understanding, you know, kind of the best ways of organizing information and data is that humans can can process it well. Okay all of this yeah and and that's hard right in it's you know. Psychology is hard right it's awful it's very kind of the same reason humans are like different and kind of inscrutable and it can be hard to understand the clear species ways of organizing things, so that humans can go and consume it easily later. 

That's that's that's a lot of what I saw for as hard but I think don't really think about that I think when people talk about software, they think it's very mythical, they don't think that lots of human issues come up. I think I think they they tend to think that the human issues are more about you know, but the you know deciding what product to build and stuff like that, but but the actual implementation of the software is is kind of, you know, sort of very methodical and straightforward, you know is a sometimes I feel like people think that's all for engineers are just like, you know these with Your two can you know manage this huge amount of like state in their working memory and and that's what makes a great software engineer or someone who can just like sort of understand all of this context kind of at once in this crazy sort of superhuman way not really no sovereign software engineered is about organizing informations that you don't need to have all of that complex right like yeah you do often need broad context of like a of a project but it's, Broad shallow context right like it's not as if you know programmers are constantly thinking about how floating the arithmetic works every time they you know, sort of need to modify, you know, how something renders in a video game because it because rendering you know involves math that's not what programmers are good at programmers aren't good at sort of thinking down that whole stack continuously at all times programmers are good figuring out how to compartmentalize that stuff so that we don't have to hold all that statement our heads. 

At one time. And I think this is also worth thinking about when it comes to you know, people understand why software is hard and and why? Why things in software can take a lot of time usually a lot longer than usual longer than maybe people expect but you know, sometimes often a lot longer than even software engineers expect and I think this is part of that to you. 

I think people don't you know, people just sort of imagine, you know, the steps that are happening. And they sort of think to themselves like oh okay yeah this you know all these steps we whatever that makes sense to me. I mean we can. We can I can imagine what those steps must look like but you know that that's sort of like not it right it's it's not just for the steps are but it's like how to organize the information for all of the steps kind of at once together. 

That's that's the. Oh, you know now as I said, I don't know this is a good example because I think what people are missing there is they're I mean, he's like a million different reasons people might think might might just misjudge how long software takes but one of them. 

I think is just the people tend to think in. In like linear flows like they look at a piece of software they think like well I'm gonna go sometimes I'm gonna press this button and press this button and press that button and see if this and then another time I'm gonna go and press this button and see that and you know, they think about almost it in this kind of like movie way with the interactions are kind of frozen their head and those things seem kind of simple and so they feel like the resulting software should be simple but what you really building is not you know, just a thing that plays those specific patterns you played out in your head. 

What you're building kind of rules that like, you know generate all such patterns that that sounds a little fancier than I than it is. I don't mean like people using machine learning to write software but you know, it's it's not that you you know, like you you picture a piece of software that like, you know, lets you book a ticket for you know a movie and not sort of all the different possible chains of bookings, yeah again, maybe. 

Maybe that's why people things offered some of the time maybe not at times. I'm sorry why people don't think software is hard. I have to think about that. 

I sort of lost my train of thought let me look at the transcript. 

Yeah, I don't know if I have a broader point than what I said in the first part. I think software is just doing software well is a complicated human problem and that's a big part of I think why we haven't yet quite figured it out``.