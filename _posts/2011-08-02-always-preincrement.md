---
layout: post
title: Always pre-increment
---
Always pre-increment. Well, unless you _need_ to post-increment, of course (ie, you're actually capturing the value of the expression and need it to be a post-increment). But when you don't care about the expression's value? Pre-increment. Why? Pre-increments can be a bit faster, but even more than that is just principle: pre-incrementing is a much simpler operation.

Consider what a pre-increment does. It takes an object (an int), modifies it (increments it), and returns the new object (the incremented int). Simple enough. Now consider a post-increment. It takes an object, modifies it, but then needs to return the state that the object was in before it was modified. Now the operation has gotten more complicated because it involves dealing with tracking past states of an object. Now, for ints, you don't really need to explicity keep track of states, you can always just subtract 1 from the int to get back to the original. In this sense, `n++` is effectively the same as `(++n,n-1)`. But the point here is that a post-increment is a more complicated operation, just in theory (and possibly in implementation, too).

You should also remember that in C++ you can "increment" more than just ints. Classes can overload both the pre- and post- increment operators (like the standard iterators do), and if they've implemented the post-increment properly, odds are they don't have a simple trick like `(++n,n-1)` to get back to the original value. Instead, they'll have to store a copy of it which they then return later. With that you might see a performance impact. It can also be an inconvenience if you want your overloaded increment operators to return references. The pre-increment can return a reference, but the post-increment would be returning a local variable that it stored, rather than the current object, and so it won't be able to return a reference (the local variable will go out of scope and die once the function returns and you'll have a dead reference).
